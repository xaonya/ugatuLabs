\documentclass[a4paper,12pt]{article}
\usepackage{array,longtable}
\usepackage{extsizes}
\usepackage{cmap} % для кодировки шрифтов в pdf
\usepackage{mathtext} % если нужны русские буквы в формулах (не обязательно)
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc} % кодировка
\usepackage[russian]{babel} %переносы
\usepackage[pdftex,unicode]{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
   
\usepackage{graphicx} % для вставки картинок
\usepackage{amssymb,amsfonts,amsmath,amsthm,latexsym,amsxtra} % математические дополнения от АМС
\usepackage[usenames,dvipsnames]{color} % названия цветов
\usepackage{makecell}
\usepackage{multirow} % улучшенное форматирование таблиц
\usepackage{ulem} % подчеркивания
  
\linespread{1.13} % междустрочный интервал
%\renewcommand{\rmdefault}{ftm} % Times New Roman
%\frenchspacing
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
 tabsize=2,
 extendedchars=\false, % надо ставить false всегда при работе с UTF-8
 commentstyle=\itshape,
 stringstyle=\bfseries,
 belowcaptionskip=5pt,
 numbers=left, % нумерация строк
 numberstyle=\tiny,
 stepnumber=1,
 language=C,
 showstringspaces=false,
 keepspaces = true,
 numbersep=8pt,
 texcl,
 frame=tb,
 breaklines=true, % автоперенос длинных линий
 breakatwhitespace=true % перенос ТОЛЬКО по пробелам и табуляциям
}
\lstdefinestyle{make}{
 language=make,
 tabsize=4
}
\renewcommand{\lstlistingname}{Листинг}
\usepackage[labelsep=period]{caption}

\setlength{\paperwidth}{210mm} \setlength{\paperheight}{297mm}
\setlength{\hoffset}{-1.04cm} \setlength{\voffset}{-0.54cm}
\setlength{\oddsidemargin}{0cm} \setlength{\evensidemargin}{0cm}
\setlength{\topmargin}{0pt} \setlength{\headheight}{0pt}
\setlength{\headsep}{0pt} \setlength{\textheight}{26.7cm}
\setlength{\textwidth}{18cm} \setlength{\marginparsep}{0pt}
\setlength{\marginparwidth}{0pt} \setlength{\footskip}{1cm}
\setlength{\marginparpush}{7pt}
\setlength{\parindent}{1cm} %\paragraph{1}

\pagestyle{empty}
\author{Ринат Ибрагимов}

\begin{document} % начало документа
\begin{titlepage} % начало титульной страницы
\begin{center} % включить выравнивание по центру
\large Государственное образовательное учереждение\\
\large высшего профессионального образования\\
\large Уфимский государственный авиационный университет\\[1.0cm]
\large кафедра математики \\[4.5cm]

\huge Отчёт по лабораторной работе № 1\\[0.6cm] % название работы, затем отступ 0,6см
\large <<Параллельное вычисление суммы числового ряда>>\\[1.0cm] % тема работы, затем отступ 4,7см
Вариант 6\\[0.5cm]
Параллельное программирование\\[4.7cm]

\begin{flushright}
\begin{minipage}{0.5\textwidth} % начало маленькой врезки в 0.6 ширины текста
\begin{flushleft} % выровнять её содержимое по левому краю
\emph{Выполнил:} Ибрагимов Р. Р.,\\
\quad студент группы ПМИ-34\\
\emph{Проверил:} Юлдашев А. В.,\\
\quad Преподаватель кафедры ВВТиС
\end{flushleft} % конец выравнивания по левому краю
\end{minipage} % конец врезки
\end{flushright}
\vfill % заполнить всё доступное ниже пространство
Уфа, УГАТУ, {\large \today} % вывести дату

{\large \LaTeX} % вывести логотип LaTeX
\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\tableofcontents % содержание

\newpage

\section{Цель работы}
Для многопроцессорных и многоядерных вычислительных систем с общей и распределённой памятью на примере задачи параллельного вычисления суммы числового ряда научиться программно реализовывать простейшие параллельные вычислительные алгоритмы и проводить анализ их эффективности.

\section{Задание на лабораторную работу}
\begin{enumerate}
 \item Написать последовательную версию программы вычисления суммы ряда на языке Си. Произвести анализ времени её выполнения при использовании компиляторов различных производителей и различных ключей оптимизации под операционными системами Windows и Linux.
 \item Выполнитть три расчёта с различными значениями N, таким образом, чтобы время работы порграммы с использованием компилятора intel составляло примерно 30, 60 и 90 секунд. Полученные результаты занести в таблицу
 \item Создать параллельную версию написанной программы путём автоматического распараллеливания средствами компилятора корпорации intel. Результаты замеров времени работы занести в таблицу.
 \item Выполнить распараллеливание последовательной программы путём включения в её текст директив интерфейса OpenMP.
 \item Вычислить ускорение и эффективность распаралеливания
 \item Написать параллельную программу с использованием базовых функций MPI.
\end{enumerate}
\subsection{Задание варианта}
$$\sum_{n=1}^N \frac{\sin(\frac{1}{n^2})}{(5n-1)^2}$$
\section{Выполнение работы}
\subsection{Написание и отладка программы}
Сперва напишем последовательную программу, скомпилируем её различными компиляторами, а затем будем её ускорять и распараллеливать как стандартными средствами компиляторов, так и путём переписывания для использования различных технологий параллелизации. Все исходные коды приведены далее.

Все программы проверяются на одной и той же машине с CPU Intel Pentium B980 2 Cores 2.4 GHz, под управлением операционной системы Ubuntu 13.10 x64 Desktop.

\paragraph{Версии}компиляторов и т.д.\\
\texttt{gcc (Ubuntu/Linaro 4.8.1-10ubuntu8) 4.8.1}\\
\texttt{icc (ICC) 14.0.0 20130728}

\subsubsection{Команды запуска}
\paragraph{GNU Compiler Collection} (GCC)

Последовательная версия:

\texttt{\$ gcc -std="c99\"\ -Wall -pedantic -o\ main onethread/main.c\ -lm\ \&\& ./main N}\\

\noindent\textbf{Примечание.} Здесь и далее $N$ -- количество элементов ряда, которые необходимо просуммировать.

\paragraph{Intel C++ Compiler} (ICC)

\texttt{\$ icc -std="c99\"\ -Wall -pedantic -o\ main onethread/main.c\ -lm\ \&\& ./main N}\\

\subsubsection{Использование ключей компилятора}
Используем ключи компиляторов, с целью выяснить, как различные опции и настройки влияют на производительность кода.

Для всех компиляторов будут проверены ключи -O1, -O2, -O3 выполняющие оптимизации размера исполняемого файла, оптимизации вызова функций (стандартные оптимизации) и интенсивные оптимизации циклов (развёртку) соответственно.

При этом для компилятора ICC будет также проверен ключ -fast, являющийся комбинацией ключей -O3 -ipo -static -xHOST -no-prec-div, при этом флаг -xHOST означает оптимизацию для того процессора, на котором запущен компилятор.

\subsection{Вычислительный кластер УГАТУ}
Coming soon... :)

\newpage
\section{Исходный код}
\subsection{Последовательная версия / встроенная параллелизация}
\lstinputlisting[caption = (onethread/main.c)]{onethread/main.c}

\newpage
\subsection{OpenMP}
\lstinputlisting[caption = (openMP/main.c)]{openMP/main.c}

\newpage
\subsection{MPI}
\lstinputlisting[caption = (mpi/main.c)]{mpi/main.c}

\newpage
\subsection{Анализ результатов}
\subsubsection{Последовательная программа}
\begin{tabular}{c | c | c c c}
\textbf{Компилятор} & \textbf{Ключи} & \textbf{N} & \textbf{Время работы, сек} & \textbf{Результат}\\
\hline
\texttt{gcc} & нет & 1400000000 & 143.140000 & 0.052592\\
\texttt{gcc} & нет & 2400000000 & 245.260000 & 0.052592\\
\texttt{gcc} & нет & 3400000000 & 347.570000 & 0.052592\\
\hline
\texttt{gcc} & \texttt{-O0} & 1400000000 & 143.110000 & 0.052592\\
\texttt{gcc} & \texttt{-O0} & 2400000000 & 245.270000 & 0.052592\\
\texttt{gcc} & \texttt{-O0} & 3400000000 & 347.650000 & 0.052592\\
\hline
\texttt{gcc} & \texttt{-O1} & 1400000000 & 126.310000 & 0.052592\\
\texttt{gcc} & \texttt{-O1} & 2400000000 & 216.570000 & 0.052592\\
\texttt{gcc} & \texttt{-O1} & 3400000000 & 306.820000 & 0.052592\\
\hline
\texttt{gcc} & \texttt{-O2} & 1400000000 & 126.040000 & 0.052592\\
\texttt{gcc} & \texttt{-O2} & 2400000000 & 216.200000 & 0.052592\\
\texttt{gcc} & \texttt{-O2} & 3400000000 & 306.180000 & 0.052592\\
\hline
\texttt{gcc} & \texttt{-O3} & 1400000000 & 126.220000 & 0.052592\\
\texttt{gcc} & \texttt{-O3} & 2400000000 & 217.200000 & 0.052592\\
\texttt{gcc} & \texttt{-O3} & 3400000000 & 308.320000 & 0.052592\\
\hline
\hline
\texttt{icc} & нет & 1400000000 & 35.290000 & 0.052592\\
\texttt{icc} & нет & 2400000000 & 60.450000 & 0.052592\\
\texttt{icc} & нет & 3400000000 & 85.650000 & 0.052592\\
\hline
\texttt{icc} & \texttt{-O0} & 1400000000 & 39.920000 & 0.052592\\
\texttt{icc} & \texttt{-O0} & 2400000000 & 68.270000 & 0.052592\\
\texttt{icc} & \texttt{-O0} & 3400000000 & 96.500000 & 0.052592\\
\hline
\texttt{icc} & \texttt{-O1} & 1400000000 & 31.820000 & 0.052592\\
\texttt{icc} & \texttt{-O1} & 2400000000 & 54.500000 & 0.052592\\
\texttt{icc} & \texttt{-O1} & 3400000000 & 77.230000 & 0.052592\\
\hline
\texttt{icc} & \texttt{-O2} & 1400000000 & 35.290000 & 0.052592\\
\texttt{icc} & \texttt{-O2} & 2400000000 & 60.800000 & 0.052592\\
\texttt{icc} & \texttt{-O2} & 3400000000 & 85.690000 & 0.052592\\
\hline
\texttt{icc} & \texttt{-O3} & 1400000000 & 35.440000 & 0.052592\\
\texttt{icc} & \texttt{-O3} & 2400000000 & 60.490000 & 0.052592\\
\texttt{icc} & \texttt{-O3} & 3400000000 & 85.650000 & 0.052592\\
\hline
\texttt{icc} & \texttt{-fast} & 1400000000 & 34.710000 & 0.052592\\
\texttt{icc} & \texttt{-fast} & 2400000000 & 59.490000 & 0.052592\\
\texttt{icc} & \texttt{-fast} & 3400000000 & 84.300000 & 0.052592\\
\hline
\end{tabular}

Тут мы видим, что даже в самом быстром случае и с меньшим количеством элементов программа, скомпилированная компилятором GCC всё-равно медленнее самой медленной программы с большим количеством элементов, скомпилированной компилятором ICC.

Также видно, что GCC по умолчанию не оптимизирует программу, а ICC как минимум выставляет флаг -O2.

В моём случае самой быстрой оказалась программа, собранная ICC с флагом -O1, выдающим минимальный размер исполняемого файла.

При этом использование ключа -fast не дало существенного ускорения кода, но сузило размеры семейства машин, на которых можно запустить расчёт с помощью этой программы.
\newpage
\section{Выводы}
\sout{Компилятор от Intel шикарен}

Из данной лабораторной работы я сделал вывод, что компиляция программы под конкретное железо, на котором она будет работать, играет существенную роль в скорости её выполнения, в данном случае, код, сгенерированный компилятором производителя моего процессора (intel) выполнялся на порядок быстрее кода, сгенерироавнного GCC для всех процессоров. Хотя дальнейшие оптимизации <<под конкретную систему>> уже не дают существенного прироста скорости выполнения.

Также, увидел, что параллелизация выполнения независимого кода позволяет существенно ускорить выполнение программы и, при этом, более-менее равномерно загрузить все системные вычислительные ресурсы, большая часть икоторых бы простаивала в случае выполнения последовательной программы.

В рамках этой работы я познакомился с способами ускорения работы программ, используя различные оптимизации, которые выполняет компилятор, встроенными средствами параллелизации, и другими технологиями распараллеливания кода, такими как OpenMP и MPI.
\vfill
\begin{center}
\small отчёт подготовлен в \LaTeX\\
Ибрагимов Ринат, УГАТУ ОНФ ПМИ-34, Уфа, \today
\end{center}
\end{document} % конец документа
